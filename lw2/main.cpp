/*

Ложкин Сергей, ПС-21
Среда: C++, CMake

1.9. Дамба (9)
В рыбохозяйстве "Рыбнастол" принято решение о разведении карасей и щук.

К сожалению, эти рыбы не могут быть вместе в одном водоеме, так как щуки предпочитают питаться исключительно карасями.
Планируется каждое из k озер разделить дамбой на две не сообщающиеся друг с другом части.
На карте каждое i-е озеро представлено в определенном масштабе прямоугольным  участком  mi × ni единиц,
разбитым на единичные квадраты. Отдельный квадрат целиком занят водой или сушей. Множество водных квадратов является связным.
Это означает, что из любого водного квадрата озера можно попасть в любой другой водный квадрат,
последовательно переходя по водным квадратам через их общую сторону.
Такие последовательности связанных квадратов будем называть путями.

Дамба имеет вид непрерывной ломаной, проходящей по сторонам квадратов.
Два водных квадрата, общая сторона которых принадлежит ломаной, становятся не сообщающимися напрямую друг с другом.
Требуется для каждого озера определить минимальную по количеству сторон длину дамбы,
разделяющей озеро на две не сообщающиеся между собой связные части.
Чтобы обеспечить доступ рыбаков к воде, каждая из двух полученных частей озера должна сообщаться с берегом.
Иными словами, каждая часть должна содержать водный квадрат,
который либо сам находится на границе исходного прямоугольного участка, либо имеет общую сторону с квадратом суши,
связанным с границей путем из квадратов суши.

Ввод.
В первой строке содержится число k (1 ≤ k ≤ 10).
В следующих строках следуют k блоков данных. Каждый блок описывает одно озеро.
В первой строке блока содержатся числа mi и ni, разделенные пробелом.
В следующих mi строках находится матрица, представляющая озеро, по ni символов в строке.
Символ '.' обозначает квадрат суши, а символ '#' – квадрат воды.
Гарантируется наличие не менее двух водных квадратов.
Общая площадь озер s = m1 × n1 + m2 × n2 + … + mk × nk не должна превосходить 106.

Вывод.
В единственной строке должны выводиться через пробел k значений, определяющих минимальные длины дамб. В
результате каждое озеро должно быть разделено на две части так,
что водные клетки из разных частей не могут иметь общей стороны, не принадлежащей дамбе.
Тем не менее касание этих клеток углами допускается.
Каждая часть должна быть связана с берегом так, как это определялось выше.

Примеры
Ввод
2
3 6
......
.####.
.####.
3 5
##.##
#####
##.##
Вывод
2 1

 */

#include <iostream>
#include <vector>

using namespace std;

const int dx4[] = {-1, 0, 1, 0};
const int dy4[] = {0, 1, 0, -1};
const int dx8[] = {-1, -1, 0, 1, 1, 1, 0, -1};
const int dy8[] = {0, 1, 1, 1, 0, -1, -1, -1};

vector<string> grid;
vector<vector<bool>> type1;  // 4-связная метка
vector<vector<bool>> type2;  // 8-связная метка
int m, n;

// 4-связная заливка суши
void flood4(int x, int y) {
    if (x < 0 || x >= m || y < 0 || y >= n) return;
    if (type1[x][y] || grid[x][y] == '#') return;

    type1[x][y] = true;
    for (int d = 0; d < 4; d++) {
        flood4(x + dx4[d], y + dy4[d]);
    }
}

// 8-связная заливка суши
void flood8(int x, int y) {
    if (x < 0 || x >= m || y < 0 || y >= n) return;
    if (type2[x][y] || grid[x][y] == '#') return;

    type2[x][y] = true;
    for (int d = 0; d < 8; d++) {
        flood8(x + dx8[d], y + dy8[d]);
    }
}

int findMinDam() {
    // Добавляем границу из суши
    grid.insert(grid.begin(), string(n+2, '.'));
    grid.push_back(string(n+2, '.'));
    for (auto& row : grid) {
        row = '.' + row + '.';
    }
    m += 2;
    n += 2;

    // Инициализация меток
    type1.assign(m, vector(n, false));
    type2.assign(m, vector(n, false));

    // 4-связная заливка
    flood4(0, 0);

    // 8-связная заливка
    flood8(0, 0);

    // Проверка всех вертикальных границ
    for (int i = 1; i < m-1; i++) {
        for (int j = 1; j < n; j++) {
            if (grid[i][j] == '#' && grid[i][j-1] == '#') {
                bool c1 = (type2[i][j] && type1[i][j]) || (type2[i][j-1] && type1[i][j-1]);
                bool c2 = type2[i][j] && type2[i][j-1];
                if (c1 && c2) return 1;
            }
        }
    }

    // Проверка всех горизонтальных границ
    for (int i = 1; i < n; i++) {
        for (int j = 1; j < n-1; j++) {
            if (grid[i][j] == '#' && grid[i-1][j] == '#') {
                bool c1 = (type2[i][j] && type1[i][j]) || (type2[i-1][j] && type1[i-1][j]);
                bool c2 = type2[i][j] && type2[i-1][j];
                if (c1 && c2) return 1;
            }
        }
    }

    return 2;
}

int main() {
    int k;
    cin >> k;
    while (k--) {
        cin >> m >> n;
        grid.resize(m);
        for (size_t i = 0; i < m; i++)
        {
        	grid[i].resize(n);
        	cin >> grid[i];
        }


        cout << findMinDam() << " ";
    }
    return 0;
}