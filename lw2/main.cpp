/*

Ложкин Сергей, ПС-21
Среда: C++, CMake

1.9. Дамба (9)
В рыбохозяйстве "Рыбнастол" принято решение о разведении карасей и щук.

К сожалению, эти рыбы не могут быть вместе в одном водоеме, так как щуки предпочитают питаться исключительно карасями.
Планируется каждое из k озер разделить дамбой на две не сообщающиеся друг с другом части.
На карте каждое i-е озеро представлено в определенном масштабе прямоугольным  участком  mi × ni единиц,
разбитым на единичные квадраты. Отдельный квадрат целиком занят водой или сушей. Множество водных квадратов является связным.
Это означает, что из любого водного квадрата озера можно попасть в любой другой водный квадрат,
последовательно переходя по водным квадратам через их общую сторону.
Такие последовательности связанных квадратов будем называть путями.

Дамба имеет вид непрерывной ломаной, проходящей по сторонам квадратов.
Два водных квадрата, общая сторона которых принадлежит ломаной, становятся не сообщающимися напрямую друг с другом.
Требуется для каждого озера определить минимальную по количеству сторон длину дамбы,
разделяющей озеро на две не сообщающиеся между собой связные части.
Чтобы обеспечить доступ рыбаков к воде, каждая из двух полученных частей озера должна сообщаться с берегом.
Иными словами, каждая часть должна содержать водный квадрат,
который либо сам находится на границе исходного прямоугольного участка, либо имеет общую сторону с квадратом суши,
связанным с границей путем из квадратов суши.

Ввод.
В первой строке содержится число k (1 ≤ k ≤ 10).
В следующих строках следуют k блоков данных. Каждый блок описывает одно озеро.
В первой строке блока содержатся числа mi и ni, разделенные пробелом.
В следующих mi строках находится матрица, представляющая озеро, по ni символов в строке.
Символ '.' обозначает квадрат суши, а символ '#' – квадрат воды.
Гарантируется наличие не менее двух водных квадратов.
Общая площадь озер s = m1 × n1 + m2 × n2 + … + mk × nk не должна превосходить 106.

Вывод.
В единственной строке должны выводиться через пробел k значений, определяющих минимальные длины дамб. В
результате каждое озеро должно быть разделено на две части так,
что водные клетки из разных частей не могут иметь общей стороны, не принадлежащей дамбе.
Тем не менее касание этих клеток углами допускается.
Каждая часть должна быть связана с берегом так, как это определялось выше.

Примеры
Ввод
2
3 6
......
.####.
.####.
3 5
##.##
#####
##.##
Вывод
2 1

 */

#include <iostream>
#include <vector>
#include <queue>
using namespace std;

typedef pair<int,int> pii;

// Функция, выполняющая заливку (BFS) с 4-связью или 8-связью.
// Если eight = true – используем 8 направлений, иначе 4 направления.
void floodFill(const vector<vector<char>> &grid, vector<vector<bool>> &vis, bool eight) {
    int R = grid.size(), C = grid[0].size();
    queue<pii> q;
    // Запускаем с клеток на границе расширенного прямоугольника
    for (int i = 0; i < R; i++) {
        for (int j = 0; j < C; j++) {
            if ((i == 0 || j == 0 || i == R-1 || j == C-1) && grid[i][j] == '.' && !vis[i][j]) {
                vis[i][j] = true;
                q.push({i,j});
            }
        }
    }
    // Направления: для 4-связи
    int d4[4][2] = { {1,0}, {-1,0}, {0,1}, {0,-1} };
    // Если 8-связь – включаем диагонали
    int d8[8][2] = { {1,0}, {-1,0}, {0,1}, {0,-1}, {1,1}, {1,-1}, {-1,1}, {-1,-1} };
    
    while(!q.empty()){
        auto [r, c] = q.front();
        q.pop();
        if(eight){
            for (int k = 0; k < 8; k++){
                int nr = r + d8[k][0], nc = c + d8[k][1];
                if(nr >= 0 && nr < R && nc >= 0 && nc < C)
                    if(grid[nr][nc]=='.' && !vis[nr][nc]){
                        vis[nr][nc] = true;
                        q.push({nr,nc});
                    }
            }
        } else {
            for (int k = 0; k < 4; k++){
                int nr = r + d4[k][0], nc = c + d4[k][1];
                if(nr >= 0 && nr < R && nc >= 0 && nc < C)
                    if(grid[nr][nc]=='.' && !vis[nr][nc]){
                        vis[nr][nc] = true;
                        q.push({nr,nc});
                    }
            }
        }
    }
}

// Для данной вершины (координаты в пространстве вершин расширенного поля)
// функция проверяет: существует ли хотя бы один соседний квадрат (из 4, сдвигами (-1,-1), (-1,0), (0,-1), (0,0)),
// который является землёй ('.') и имеет метку внешности по 4-связи (t1) или по 8-связи (t2).
// Обратите внимание: grid, t1, t2 имеют размер (m+2) x (n+2) – клетки расширенного прямоугольника.
pair<bool,bool> checkVertex(int r, int c, const vector<vector<char>> &grid,
                              const vector<vector<bool>> &t1,
                              const vector<vector<bool>> &t2) {
    bool hasT1 = false, hasT2 = false;
    int R = grid.size(), C = grid[0].size();
    // Рассмотрим квадраты, соседние с вершиной (r, c):
    // возможные координаты верхнего левого угла: (r-1, c-1), (r-1, c), (r, c-1), (r, c)
    for (int dr = -1; dr <= 0; dr++){
        for (int dc = -1; dc <= 0; dc++){
            int nr = r + dr, nc = c + dc;
            if(nr >= 0 && nr < R && nc >= 0 && nc < C){
                if(grid[nr][nc] == '.') {
                    if(t1[nr][nc]) hasT1 = true;
                    if(t2[nr][nc]) hasT2 = true;
                }
            }
        }
    }
    return {hasT1, hasT2};
}

int main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int k;
    cin >> k;
    // Будем сохранять ответы для всех озер
    vector<int> ans(k, 2);
    for (int idx = 0; idx < k; idx++){
        int m, n;
        cin >> m >> n;
        // Создаем расширенное поле размером (m+2) x (n+2)
        vector<vector<char>> grid(m+2, vector<char>(n+2, '.'));
        // Заполняем внутреннюю часть входными данными
        for (int i = 1; i <= m; i++){
            string line;
            cin >> line;
            for (int j = 1; j <= n; j++){
                grid[i][j] = line[j-1];
            }
        }
        int R = m+2, C = n+2;
        // Массивы для меток внешности
        vector<vector<bool>> ext4(R, vector<bool>(C, false)); // тип 1
        vector<vector<bool>> ext8(R, vector<bool>(C, false)); // тип 2

        // Запускаем заливку по 4-связи для земных клеток
        floodFill(grid, ext4, false);
        // Запускаем заливку по 8-связи для земных клеток
        floodFill(grid, ext8, true);

        bool foundDam1 = false;
        // Перебираем кандидатов на дамбу единичной длины.
        // Рассмотрим соседние пары водных клеток внутри исходного озера:
        // клетки озера находятся с индексами [1, m] x [1, n] в grid.
        // Горизонтальные соседи:
        for (int i = 1; i <= m; i++){
            for (int j = 1; j < n; j++){
                if(grid[i][j]=='#' && grid[i][j+1]=='#'){
                    // Для двух горизонтально соседних клеток их общая сторона – вертикальный отрезок.
                    // Вершины отрезка: верхняя: (i-1, j) и нижняя: (i, j) (в координатах вершин расширенного поля)
                    auto [hasT1_1, hasT2_1] = checkVertex(i-1, j, grid, ext4, ext8);
                    auto [hasT1_2, hasT2_2] = checkVertex(i, j, grid, ext4, ext8);
                    // Условие: оба конца должны иметь метку типа2, и хотя бы один из них – типа1.
                    if(hasT2_1 && hasT2_2 && (hasT1_1 || hasT1_2)){
                        foundDam1 = true;
                        goto finish;
                    }
                }
            }
        }
        // Вертикальные соседи:
        for (int i = 1; i < m; i++){
            for (int j = 1; j <= n; j++){
                if(grid[i][j]=='#' && grid[i+1][j]=='#'){
                    // Для вертикально соседних клеток общая сторона – горизонтальный отрезок.
                    // Вершины отрезка: левая: (i, j-1) и правая: (i, j)
                    auto [hasT1_1, hasT2_1] = checkVertex(i, j-1, grid, ext4, ext8);
                    auto [hasT1_2, hasT2_2] = checkVertex(i, j, grid, ext4, ext8);
                    if(hasT2_1 && hasT2_2 && (hasT1_1 || hasT1_2)){
                        foundDam1 = true;
                        goto finish;
                    }
                }
            }
        }
finish:
        ans[idx] = foundDam1 ? 1 : 2;
    }
    // Выводим k ответов через пробел в одной строке
    for (int i = 0; i < k; i++){
        cout << ans[i] << (i+1 < k ? " " : "\n");
    }
    return 0;
}
