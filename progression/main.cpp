/*
4.1. Прогрессия (6)
Король Камбузии с детства боится несчастливых арифметических прогрессий с разностью 13.
Однажды ему представили список расходов на нужды подданных, состоящий из N чисел.
Король потребовал оставить только такую начальную часть списка, в которой не скрывается несчастливая арифметическая прогрессия.
Либеральная общественность, считаясь с мнением короля, настаивает, тем не менее, на сохранении как можно большей части списка.
Найти максимальное значение K такое, что из первых K чисел списка невозможно выделить M чисел,
следующих в порядке их нахождения в списке и образующих последовательные члены несчастливой арифметической прогрессии.
Выдать члены первой обнаруженной несчастливой прогрессии.

Ввод из файла INPUT.TXT.
Первая строка содержит два целых положительных числа N и M, разделенных пробелом: N – количество чисел в списке,
а M – недопустимое число членов прогрессии. Вторая строка содержит список расходов в виде целых положительных чисел.
Ограничения: 2 ≤ N, M ≤ 5000, 1 ≤ Xi ≤ 65000, время 1 с.

Вывод в файл OUTPUT.TXT. В первой строке выводится единственное число K- максимальное количество начальных чисел списка, не содержащих в качестве подсписка M последовательных членов несчастливой арифметической прогрессии. Во второй строке выводятся через пробел члены первой обнаруженной несчастливой прогрессии. Если ее не обнаружено, вывести No.

Пример
Ввод
9 3
5 9 3 22 16 19 35 7 29
Вывод
6
9 22 35
Пояснение: из первых 7 чисел выделяются 3 члена несчастливой прогрессии 9, 22, 35,
а из первых 6 чисел можно выделить только 2 таких члена: 9, 22 либо 3, 16.
*/

#include <fstream>
#include <vector>

using namespace std;

int main(const int _, const char* argv[])
{
	std::ifstream fin(argv[1]);
	std::ofstream fout(argv[2]);
	int N, M;
	fin >> N >> M;

	vector<int> arr(N);
	for (int i = 0; i < N; i++)
	{
		fin >> arr[i];
	}

	int K = 0;
	vector<int> progression;

	for (int len = 1; len <= N; len++)
	{
		bool found = false;
		for (int start = 0; start <= len - M; start++)
		{
			bool isProgression = true;
			for (int j = start + 1; j < start + M; j++)
			{
				if (arr[j] - arr[j - 1] != 13)
				{
					isProgression = false;
					break;
				}
			}
			if (isProgression)
			{
				found = true;
				if (progression.empty())
				{
					// Сохраняем первую найденную прогрессию
					for (int j = start; j < start + M; j++)
					{
						progression.push_back(arr[j]);
					}
				}
				break;
			}
		}
		if (!found)
		{
			K = len;
		}
		else
		{
			break;
		}
	}

	// Выводим результат
	fout << K << endl;
	if (progression.empty())
	{
		fout << "No";
	}
	else
	{
		for (int i = 0; i < progression.size(); i++)
		{
			fout << progression[i];
			if (i < progression.size() - 1)
				fout << " ";
		}
	}

	fin.close();
	fout.close();
	return 0;
}